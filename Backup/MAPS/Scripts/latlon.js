function LatLon(t, a, o) { "undefined" == typeof o && (o = 6371), this._lat = "number" == typeof t ? t : "string" == typeof t && "" != t.trim() ? +t : 0 / 0, this._lon = "number" == typeof a ? a : "string" == typeof a && "" != a.trim() ? +a : 0 / 0, this._radius = "number" == typeof o ? o : "string" == typeof o && "" != trim(a) ? +o : 0 / 0 } LatLon.prototype.distanceTo = function (t, a) { "undefined" == typeof a && (a = 4); var o = this._radius, n = this._lat.toRad(), h = this._lon.toRad(), i = t._lat.toRad(), s = t._lon.toRad(), M = i - n, l = s - h, e = Math.sin(M / 2) * Math.sin(M / 2) + Math.cos(n) * Math.cos(i) * Math.sin(l / 2) * Math.sin(l / 2), r = 2 * Math.atan2(Math.sqrt(e), Math.sqrt(1 - e)), d = o * r; return d.toPrecisionFixed(a) }, LatLon.prototype.bearingTo = function (t) { var a = this._lat.toRad(), o = t._lat.toRad(), n = (t._lon - this._lon).toRad(), h = Math.sin(n) * Math.cos(o), i = Math.cos(a) * Math.sin(o) - Math.sin(a) * Math.cos(o) * Math.cos(n), s = Math.atan2(h, i); return (s.toDeg() + 360) % 360 }, LatLon.prototype.finalBearingTo = function (t) { var a = t._lat.toRad(), o = this._lat.toRad(), n = (this._lon - t._lon).toRad(), h = Math.sin(n) * Math.cos(o), i = Math.cos(a) * Math.sin(o) - Math.sin(a) * Math.cos(o) * Math.cos(n), s = Math.atan2(h, i); return (s.toDeg() + 180) % 360 }, LatLon.prototype.midpointTo = function (t) { lat1 = this._lat.toRad(), lon1 = this._lon.toRad(), lat2 = t._lat.toRad(); var a = (t._lon - this._lon).toRad(), o = Math.cos(lat2) * Math.cos(a), n = Math.cos(lat2) * Math.sin(a); return lat3 = Math.atan2(Math.sin(lat1) + Math.sin(lat2), Math.sqrt((Math.cos(lat1) + o) * (Math.cos(lat1) + o) + n * n)), lon3 = lon1 + Math.atan2(n, Math.cos(lat1) + o), lon3 = (lon3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI, new LatLon(lat3.toDeg(), lon3.toDeg()) }, LatLon.prototype.destinationPoint = function (t, a) { a = "number" == typeof a ? a : "string" == typeof a && "" != a.trim() ? +a : 0 / 0, a /= this._radius, t = t.toRad(); var o = this._lat.toRad(), n = this._lon.toRad(), h = Math.asin(Math.sin(o) * Math.cos(a) + Math.cos(o) * Math.sin(a) * Math.cos(t)), i = n + Math.atan2(Math.sin(t) * Math.sin(a) * Math.cos(o), Math.cos(a) - Math.sin(o) * Math.sin(h)); return i = (i + 3 * Math.PI) % (2 * Math.PI) - Math.PI, new LatLon(h.toDeg(), i.toDeg()) }, LatLon.intersection = function (t, a, o, n) { return a = "number" == typeof a ? a : "string" == typeof a && "" != trim(a) ? +a : 0 / 0, n = "number" == typeof n ? n : "string" == typeof n && "" != trim(n) ? +n : 0 / 0, lat1 = t._lat.toRad(), lon1 = t._lon.toRad(), lat2 = o._lat.toRad(), lon2 = o._lon.toRad(), brng13 = a.toRad(), brng23 = n.toRad(), dLat = lat2 - lat1, dLon = lon2 - lon1, dist12 = 2 * Math.asin(Math.sqrt(Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) * Math.sin(dLon / 2))), 0 == dist12 ? null : (brngA = Math.acos((Math.sin(lat2) - Math.sin(lat1) * Math.cos(dist12)) / (Math.sin(dist12) * Math.cos(lat1))), isNaN(brngA) && (brngA = 0), brngB = Math.acos((Math.sin(lat1) - Math.sin(lat2) * Math.cos(dist12)) / (Math.sin(dist12) * Math.cos(lat2))), Math.sin(lon2 - lon1) > 0 ? (brng12 = brngA, brng21 = 2 * Math.PI - brngB) : (brng12 = 2 * Math.PI - brngA, brng21 = brngB), alpha1 = (brng13 - brng12 + Math.PI) % (2 * Math.PI) - Math.PI, alpha2 = (brng21 - brng23 + Math.PI) % (2 * Math.PI) - Math.PI, 0 == Math.sin(alpha1) && 0 == Math.sin(alpha2) ? null : Math.sin(alpha1) * Math.sin(alpha2) < 0 ? null : (alpha3 = Math.acos(-Math.cos(alpha1) * Math.cos(alpha2) + Math.sin(alpha1) * Math.sin(alpha2) * Math.cos(dist12)), dist13 = Math.atan2(Math.sin(dist12) * Math.sin(alpha1) * Math.sin(alpha2), Math.cos(alpha2) + Math.cos(alpha1) * Math.cos(alpha3)), lat3 = Math.asin(Math.sin(lat1) * Math.cos(dist13) + Math.cos(lat1) * Math.sin(dist13) * Math.cos(brng13)), dLon13 = Math.atan2(Math.sin(brng13) * Math.sin(dist13) * Math.cos(lat1), Math.cos(dist13) - Math.sin(lat1) * Math.sin(lat3)), lon3 = lon1 + dLon13, lon3 = (lon3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI, new LatLon(lat3.toDeg(), lon3.toDeg()))) }, LatLon.prototype.rhumbDistanceTo = function (t) { var a = this._radius, o = this._lat.toRad(), n = t._lat.toRad(), h = (t._lat - this._lat).toRad(), i = Math.abs(t._lon - this._lon).toRad(), s = Math.log(Math.tan(n / 2 + Math.PI / 4) / Math.tan(o / 2 + Math.PI / 4)), M = isFinite(h / s) ? h / s : Math.cos(o); Math.abs(i) > Math.PI && (i = i > 0 ? -(2 * Math.PI - i) : 2 * Math.PI + i); var l = Math.sqrt(h * h + M * M * i * i) * a; return l.toPrecisionFixed(4) }, LatLon.prototype.rhumbBearingTo = function (t) { var a = this._lat.toRad(), o = t._lat.toRad(), n = (t._lon - this._lon).toRad(), h = Math.log(Math.tan(o / 2 + Math.PI / 4) / Math.tan(a / 2 + Math.PI / 4)); Math.abs(n) > Math.PI && (n = n > 0 ? -(2 * Math.PI - n) : 2 * Math.PI + n); var i = Math.atan2(n, h); return (i.toDeg() + 360) % 360 }, LatLon.prototype.rhumbDestinationPoint = function (t, a) { var o = this._radius, n = parseFloat(a) / o, h = this._lat.toRad(), i = this._lon.toRad(); t = t.toRad(); var s = n * Math.cos(t); Math.abs(s) < 1e-10 && (s = 0); var M = h + s, l = Math.log(Math.tan(M / 2 + Math.PI / 4) / Math.tan(h / 2 + Math.PI / 4)), e = isFinite(s / l) ? s / l : Math.cos(h), r = n * Math.sin(t) / e; return Math.abs(M) > Math.PI / 2 && (M = M > 0 ? Math.PI - M : -Math.PI - M), lon2 = (i + r + 3 * Math.PI) % (2 * Math.PI) - Math.PI, new LatLon(M.toDeg(), lon2.toDeg()) }, LatLon.prototype.rhumbMidpointTo = function (t) { lat1 = this._lat.toRad(), lon1 = this._lon.toRad(), lat2 = t._lat.toRad(), lon2 = t._lon.toRad(), Math.abs(lon2 - lon1) > Math.PI && (lon1 += 2 * Math.PI); var a = (lat1 + lat2) / 2, o = Math.tan(Math.PI / 4 + lat1 / 2), n = Math.tan(Math.PI / 4 + lat2 / 2), h = Math.tan(Math.PI / 4 + a / 2), i = ((lon2 - lon1) * Math.log(h) + lon1 * Math.log(n) - lon2 * Math.log(o)) / Math.log(n / o); return isFinite(i) || (i = (lon1 + lon2) / 2), i = (i + 3 * Math.PI) % (2 * Math.PI) - Math.PI, new LatLon(a.toDeg(), i.toDeg()) }, LatLon.prototype.lat = function (t, a) { return "undefined" == typeof t ? this._lat : Geo.toLat(this._lat, t, a) }, LatLon.prototype.lon = function (t, a) { return "undefined" == typeof t ? this._lon : Geo.toLon(this._lon, t, a) }, LatLon.prototype.toString = function (t, a) { return "undefined" == typeof t && (t = "dms"), Geo.toLat(this._lat, t, a) + ", " + Geo.toLon(this._lon, t, a) }, "undefined" == typeof Number.prototype.toRad && (Number.prototype.toRad = function () { return this * Math.PI / 180 }), "undefined" == typeof Number.prototype.toDeg && (Number.prototype.toDeg = function () { return 180 * this / Math.PI }), "undefined" == typeof Number.prototype.toPrecisionFixed && (Number.prototype.toPrecisionFixed = function (t) { var a = this.toPrecision(t); return a = a.replace(/(.+)e\+(.+)/, function (t, a, o) { for (a = a.replace(/\./, ""), l = a.length - 1; o-- > l; ) a += "0"; return a }), a = a.replace(/(.+)e-(.+)/, function (t, a, o) { for (a = a.replace(/\./, ""); o-- > 1; ) a = "0" + a; return "0." + a }) }), "undefined" == typeof String.prototype.trim && (String.prototype.trim = function () { return String(this).replace(/^\s\s*/, "").replace(/\s\s*$/, "") }), window.console || (window.console = { log: function () { } });